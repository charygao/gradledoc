<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>第五十六章.&nbsp;多项目构建 - Chapter&nbsp;56.&nbsp;Multi-project Builds</title>
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css">
  <meta content="DocBook XSL Stylesheets V1.75.2" name="generator">
  <link rel="home" href="userguide.html" title="Gradle 用户指南">
  <link rel="up" href="userguide.html" title="Gradle 用户指南">
  <link rel="prev" href="build_lifecycle.html" title="第五十五章. 构建的生命周期">
  <link rel="next" href="custom_tasks.html" title="第五十七章. 编写自定义任务类">
 </head>
 <body>
  <div class="navheader">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="第五十五章. 构建的生命周期">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="custom_tasks.html" title="第五十七章. 编写自定义任务类">下一章</a>
    </div>
   </div>
  </div>
  <div class="chapter">
   <div class="titlepage">
    <div>
     <div>
      <h1 xmlns:xslthl="http://xslthl.sf.net"><a name="multi_project_builds"></a>第五十六章.&nbsp;多项目构建</h1>
      <h3 xmlns:xslthl="http://xslthl.sf.net"><a name="multi_project_builds"></a>Chapter&nbsp;56.&nbsp;Multi-project Builds</h3>
     </div>
    </div>
   </div>
   <p>对多项目构建的强大支持是 Gradle 的独特优点之一。而本主题也是最具智力挑战的主题。 <br>The powerful support for multi-project builds is one of Gradle's unique selling points. This topic is also the most intellectually challenging.</p>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:cross_project_configuration"></a>56.1. 跨项目配置</h2>
       <h4 class="title"><a name="sec:cross_project_configuration"></a>56.1.&nbsp;Cross project configuration</h4>
      </div>
     </div>
    </div>
    <p>让我们从一个非常简单的多项目构建开始。毕竟 Gradle 核心上是一个通用的构建工具，因此所构建的项目不一定得是 Java 项目。我们的第一个例子是关于海洋生物的。 <br>Let's start with a very simple multi-project build. After all Gradle is a general purpose build tool at its core, so the projects don't have to be java projects. Our first examples are about marine life.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15FA2"></a>56.1.1. 配置和执行</h3>
        <h5 class="title"><a name="N15FA2"></a>56.1.1.&nbsp;Configuration and execution</h5>
       </div>
      </div>
     </div>
     <p>《<a class="xref" href="build_lifecycle.html#sec:build_phases">第55.1节，构建阶段</a>》描述了每个 Gradle 构建的阶段。让我们放大多项目构建的配置和执行阶段。在执行任何任务之前，会进行所有项目的配置。这意味着，当请求一个项目里的某个任务时，首先会配置多项目构建的<span class="emphasis"><em>所有</em></span>项目。所有项目需要配置的原因是为了支持灵活地访问及更改 Gradle 项目模型的任何部分。 <br><a class="xref" href="build_lifecycle.html#sec:build_phases">Section&nbsp;55.1, “Build phases”</a> describes the phases of every Gradle build. Let's zoom into configuration and execution phases of a multi-project build. The configuration of all projects happens before any task is executed. This means that when a single task, from a single project is requested, <span class="emphasis"><em>all</em></span> projects of multi-project build are configured first. The reason every project needs to be configured is to support the flexibility of accessing and changing any part of Gradle project model.</p>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sec:configuration_on_demand"></a>56.1.1.1. 按需配置</h4>
         <h6 class="title"><a name="sec:configuration_on_demand"></a>56.1.1.1.&nbsp;Configuration on demand</h6>
        </div>
       </div>
      </div>
      <p>由于每个项目都在执行阶段开始之前配置，所以可以做到配置注入功能以及对完整项目模型的访问。然而，在一个非常大的多项目构建中，这种方法可能不是最有效的。有一些 Gradle 构建，它们在层次结构上会有上百个的子项目。对于大型的多项目，构建的配置时间可能会变得很明显。可扩展性是 Gradle 的一项重要需求，因此从 V1.4 开始，新引入了一个试验性的“按需配置”模式。<br>Configuration injection feature and access to the complete project model are possible because every project is configured before the execution phase. Yet, this approach may not be the most efficient in a very large multi-project builds. There are Gradle builds with a hierarchy of hundreds of subprojects. Configuration time of huge multi-project builds may become noticeable. Scalability is an important requirement for Gradle. Hence, starting from version 1.4 new incubating 'configuration on demand' mode is introduced.</p>
      <p> 按需配置模式尝试只配置与所请求的任务相关的项目，这样就大大地改善了大型多项目构建的配置时间。长远来看，这种模式将成为默认模式，可能会是 Gradle 构建执行的唯一模式。按需配置功能还处于试验性阶段，因此无法保证每个构建都能正确。对于解耦的多项目构建（《<a class="xref" href="multi_project_builds.html#sec:decoupled_projects">第56.9节，解耦项目</a>》），这个功能部件应该非常有效。在按需配置的模式中，项目配置如下： <br>Configuration on demand mode attempts to configure only projects that are relevant for requested tasks. This way, the configuration time of a large multi-project build is greatly improved. In the long term, this mode will become the default mode, possibly the only mode for Gradle build execution. The configuration on demand feature is incubating so not every build is guaranteed to work correctly. The feature should work very well for multi-project builds that have decoupled projects (<a class="xref" href="multi_project_builds.html#sec:decoupled_projects">Section&nbsp;56.9, “Decoupled Projects”</a>). In configuration on demand mode projects are configured as follows:</p>
      <div class="itemizedlist">
       <ul class="itemizedlist">
        <li class="listitem">根项目始终会被配置。这种方式支持典型的公共配置（allprojects 或subprojects 脚本块）。<br>Root project is always configured. This way the typical common configuration is supported (allprojects or subprojects script blocks).</li>
        <li class="listitem">执行构建的所在目录的项目也会被配置，但是只在没有任何任务的情况下执行 Gradle 时。这种方式当项目按需配置时，默认任务会正常运行。<br>Project in the directory where the build is executed is also configured, but only when Gradle is executed without any tasks. This way the default tasks behave correctly when projects are configured on demand.</li>
        <li class="listitem">标准项目的依赖被支持，并且使相关的项目也被配置。如果项目 A 对项目 B 有编译依赖，那么构建 A 的时候也会导致这两个项目的配置。<br>The standard project dependencies are supported and makes relevant projects configured. If project A has a compile dependency on project B then building A causes configuration of both projects: A and B.</li>
        <li class="listitem">通过任务路径定义的任务依赖也被支持，并且会导致相关的项目被配置。示例：someTask.dependsOn(":someOtherProject:someOtherTask") <br>The task dependencies declared via task path are supported and cause relevant projects configured. Example: someTask.dependsOn(":someOtherProject:someOtherTask")</li>
        <li class="listitem">通过从命令行（或 Tooling API）中的任务路径所请求的任务将导致相关的项目被配置。构建 'projectA:projectB:someTask' 会使项目 B 被配置。 <br>Task requested via task path from the command line (or Tooling API) causes the relevant project configured. Building 'projectA:projectB:someTask' causes configuration of projectB.</li>
       </ul>
      </div>
      <p> </p>
      <p> 想试试这个新功能吗？要在每次构建时都按需配置，请参阅《<a class="xref" href="build_environment.html#sec:gradle_configuration_properties">第20.1节，通过 gradle.properties 配置构建环境</a>》。 只对给定的构建按需配置，请参阅《<a class="xref" href="gradle_command_line.html">附录D，<i>Gradle 命令行</i></a>》。 <br>Eager to try out this new feature? To configure on demand with every build run see <a class="xref" href="build_environment.html#sec:gradle_configuration_properties">Section&nbsp;20.1, “Configuring the build environment via gradle.properties”</a>. To configure on demand just for given build please see <a class="xref" href="gradle_command_line.html">Appendix&nbsp;D, <i>Gradle Command Line</i></a>.</p>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N15FCB"></a>56.1.2.&nbsp;定义共同行为</h3>
        <h5 class="title"><a name="N15FCB"></a>56.1.2.&nbsp;Defining common behavior</h5>
       </div>
      </div>
     </div>
     <p>我们有以下项目树。 它是一个多项目构建，有一个根项目 <code class="literal">water</code> 和子项目 <code class="literal">bluewhale</code>。 <br>We have the following project tree. This is a multi-project build with a root project <code class="literal">water</code> and a subproject <code class="literal">bluewhale</code>.</p>
     <div class="example">
      <a name="multiprojectFirstExample"></a>
      <p class="title"><b>示例 56.1. 多项目树——water &amp; bluewhale 项目 - Example&nbsp;56.1.&nbsp;Multi-project tree - water &amp; bluewhale projects</b></p>
      <div class="example-contents">
       <p>构建布局<br>Build layout</p>
       <pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/</pre>
       <div class="exampleLocation">
        <p><span class="emphasis"><em>注︰</em> </span>此示例的代码可以在 Gradle 的二进制及源码分发包的<code class="filename">samples/userguide/multiproject/firstExample/water</code> 中找到。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/firstExample/water</code> which is in both the binary and source distributions of Gradle.</p>
       </div>
       <p><code class="filename">settings.gradle</code></p>
       <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'bluewhale'</span></pre>
      </div>
     </div>
     <br class="example-break">
     <p>那么，<code class="literal">bluewhale</code> 项目的构建脚本在哪里呢？在 Gradle 中，构建脚本是可选的。显然，对于单项目构建而言，没有构建脚本的项目没有多大意义。但对于多项目构建，情况就不同了。让我们看看 <code class="literal">water</code> 项目的构建脚本并执行它： <br>And where is the build script for the <code class="literal">bluewhale</code> project? In Gradle build scripts are optional. Obviously for a single project build, a project without a build script doesn't make much sense. For multiproject builds the situation is different. Let's look at the build script for the <code class="literal">water</code> project and execute it:</p>
     <div class="example">
      <a name="multiprojectFirstExample"></a>
      <p class="title"><b>示例 56.2. water（父）项目的构建脚本 - Example&nbsp;56.2.&nbsp;Build script of water (parent) project</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">Closure cl = { task -&gt; println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"I'm $task.project.name"</span> }
task hello &lt;&lt; cl
project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':bluewhale'</span>) {
    task hello &lt;&lt; cl
}</pre>
       <p><strong class="userinput"><code>gradle -q hello</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p>
       <pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale</pre>
      </div>
     </div>
     <br class="example-break">
     <p>Gradle 允许你从任何构建脚本中访问多项目构建的任何项目。Project API 提供了一个叫做 <code class="literal">project()</code> 的方法，它将路径作为参数，返回此路径的 Project 对象。这种从任何构建脚本中配置项目构建的功能，我们称之为<em class="firstterm">跨项目配置</em>。Gradle 通过<em class="firstterm">配置注入</em>来实现它。 <br>Gradle allows you to access any project of the multi-project build from any build script. The Project API provides a method called <code class="literal">project()</code>, which takes a path as an argument and returns the Project object for this path. The capability to configure a project build from any build script we call <em class="firstterm">cross project configuration</em>. Gradle implements this via <em class="firstterm">configuration injection</em>.</p>
     <p>我们对这个 <code class="literal">water</code> 项目的构建脚本不是很满意，因为要为每个项目显式地添加任务很不方便。我们可以进行改善。让我们首先将另一个名为 <code class="literal">krill</code> 的项目添加到我们的多项目构建中。 <br>We are not that happy with the build script of the <code class="literal">water</code> project. It is inconvenient to add the task explicitly for every project. We can do better. Let's first add another project called <code class="literal">krill</code> to our multi-project build.</p>
     <div class="example">
      <a name="multiprojectAddKrill"></a>
      <p class="title"><b>示例 56.3. 多项目树——water &amp; bluewhale &amp; krill 项目 - Example&nbsp;56.3.&nbsp;Multi-project tree - water, bluewhale &amp; krill projects</b></p>
      <div class="example-contents">
       <p>构建布局<br>Build layout</p>
       <pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/
  krill/</pre>
       <div class="exampleLocation">
        <p><span class="emphasis"><em>注︰</em> </span>此示例的代码可以在 Gradle 的二进制及源码分发包的 <code class="filename">samples/userguide/multiproject/firstExample/water</code> 中找到。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/addKrill/water</code> which is in both the binary and source distributions of Gradle.</p>
       </div>
       <p><code class="filename">settings.gradle</code></p>
       <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'bluewhale'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'krill'</span></pre>
      </div>
     </div>
     <br class="example-break">
     <p>现在我们改写 <code class="literal">water</code> 的构建脚本，并把它归结成为一行。<br>Now we rewrite the <code class="literal">water</code> build script and boil it down to a single line.</p>
     <div class="example">
      <a name="multiprojectAddKrill"></a>
      <p class="title"><b>示例 56.4. Water 项目构建脚本 - Example&nbsp;56.4.&nbsp;Water project build script</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">allprojects {
    task hello &lt;&lt; { task -&gt; println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"I'm $task.project.name"</span> }
}</pre>
       <p><strong class="userinput"><code>gradle -q hello</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p>
       <pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
I'm krill</pre>
      </div>
     </div>
     <br class="example-break">
     <p>是刚才那个酷还是现在这个酷？它又是怎么实现的呢？Project API 提供了一个 <code class="literal">allprojects</code> 属性，它返回一个包含当前项目及其下面的所有子项目的列表。如果你使用一个闭包调用 <code class="literal">allprojects</code> ，那么闭包的语句将委派给与 <code class="literal"> allprojects</code> 相关联的项目。你也可以通过 <code class="literal">allprojects.each</code> 来执行迭代，但这样写会比较冗长。 <br>Is this cool or is this cool? And how does this work? The Project API provides a property <code class="literal">allprojects</code> which returns a list with the current project and all its subprojects underneath it. If you call <code class="literal">allprojects</code> with a closure, the statements of the closure are delegated to the projects associated with <code class="literal"> allprojects</code>. You could also do an iteration via <code class="literal">allprojects.each</code>, but that would be more verbose.</p>
     <p>其他构建系统使用继承作为定义公共行为的主要方法。稍后你会看到，我们也提供了项目继承。但 Gradle 使用配置注入作为定义共同行为的常用方法。我们认为它提供了一种非常强大且灵活的方式来配置多项目构建。 <br>Other build systems use inheritance as the primary means for defining common behavior. We also offer inheritance for projects as you will see later. But Gradle uses configuration injection as the usual way of defining common behavior. We think it provides a very powerful and flexible way of configuring multiproject builds.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:subproject_configuration"></a>56.2.&nbsp;子项目配置</h2>
       <h4 class="title"><a name="sec:subproject_configuration"></a>56.2.&nbsp;Subproject configuration</h4>
      </div>
     </div>
    </div>
    <p>Project API 还提供了一个属性只用于访问子项目。 <br>The Project API also provides a property for accessing the subprojects only.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N1605A"></a>56.1.2.&nbsp;定义共同行为</h3>
        <h5 class="title"><a name="N1605A"></a>56.2.1.&nbsp;Defining common behavior</h5>
       </div>
      </div>
     </div>
     <div class="example">
      <a name="multiprojectUseSubprojects"></a>
      <p class="title"><b>示例 56.5. 定义所有项目以及子项目的共同行为 - Example&nbsp;56.5.&nbsp;Defining common behaviour of all projects and subprojects</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">allprojects {
    task hello &lt;&lt; {task -&gt; println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"I'm $task.project.name"</span> }
}
subprojects {
    hello &lt;&lt; {println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- I depend on water"</span>}
}</pre>
       <p><strong class="userinput"><code>gradle -q hello</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p>
       <pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
I'm krill
- I depend on water</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:adding_specific_behavior"></a>56.2.2. 添加特定行为</h3>
        <h5 class="title"><a name="sub:adding_specific_behavior"></a>56.2.2.&nbsp;Adding specific behavior</h5>
       </div>
      </div>
     </div>
     <p>你可以在共同行为的上面再添加特定行为。通常我们会把项目的特定行为放在要应用该行为的项目的构建脚本里。但正如我们已经看到的，我们可以不这样做。我们可以这样为 <code class="literal">bluewhale</code> 项目添加项目的特定行为： <br>You can add specific behavior on top of the common behavior. Usually we put the project specific behavior in the build script of the project where we want to apply this specific behavior. But as we have already seen, we don't have to do it this way. We could add project specific behavior for the <code class="literal">bluewhale</code> project like this:</p>
     <div class="example">
      <a name="multiprojectSubprojectsAddFromTop"></a>
      <p class="title"><b>示例 56.6. 定义特定项目的特定行为 - Example&nbsp;56.6.&nbsp;Defining specific behaviour for particular project</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">allprojects {
    task hello &lt;&lt; {task -&gt; println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"I'm $task.project.name"</span> }
}
subprojects {
    hello &lt;&lt; {println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- I depend on water"</span>}
}
project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':bluewhale'</span>).hello &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- I'm the largest animal that has ever lived on this planet."</span>
}</pre>
       <p><strong class="userinput"><code>gradle -q hello</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p>
       <pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
I'm krill
- I depend on water</pre>
      </div>
     </div>
     <br class="example-break">
     <p>正如前面所说，我们通常倾向于将特定于项目的行为放入该项目的构建脚本中。让我们重构并将一些项目特定行为添加到 <code class="literal">krill</code> 项目中。 <br>As we have said, we usually prefer to put project specific behavior into the build script of this project. Let's refactor and also add some project specific behavior to the <code class="literal">krill</code> project.</p>
     <div class="example">
      <a name="multiprojectSpreadSpecifics"></a>
      <p class="title"><b>示例 56.7. 为 krill 项目定义特定行为 - Example&nbsp;56.7.&nbsp;Defining specific behaviour for project krill</b></p>
      <div class="example-contents">
       <p>构建布局<br>Build layout</p>
       <pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/
    build.gradle
  krill/
    build.gradle</pre>
       <div class="exampleLocation">
        <p><span class="emphasis"><em>注︰</em> </span>此示例的代码可以在 Gradle 的二进制及源码分发包的<code class="filename">samples/userguide/multiproject/spreadSpecifics/water</code> 中找到。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/spreadSpecifics/water</code> which is in both the binary and source distributions of Gradle.</p>
       </div>
       <p><code class="filename">settings.gradle</code></p>
       <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'bluewhale'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'krill'</span></pre>
       <p><code class="filename">bluewhale/build.gradle</code></p>
       <pre class="programlisting">hello.doLast { println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- I'm the largest animal that has ever lived on this planet."</span> }</pre>
       <p><code class="filename">krill/build.gradle</code></p>
       <pre class="programlisting">hello.doLast {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- The weight of my species in summer is twice as heavy as all human beings."</span>
}</pre>
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">allprojects {
    task hello &lt;&lt; {task -&gt; println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"I'm $task.project.name"</span> }
}
subprojects {
    hello &lt;&lt; {println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- I depend on water"</span>}
}</pre>
       <p><strong class="userinput"><code>gradle -q hello</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p>
       <pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
I'm krill
- I depend on water
- The weight of my species in summer is twice as heavy as all human beings.</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:project_filtering"></a>56.2.3. 项目过滤</h3>
        <h5 class="title"><a name="sub:project_filtering"></a>56.2.3.&nbsp;Project filtering</h5>
       </div>
      </div>
     </div>
     <p>要体现配置注入的更强大之处，让我们添加另一个项目 <code class="literal">tropicalFish</code>，并通过 <code class="literal">water</code> 项目的构建脚本向这个构建添加更多的行为。 <br>To show more of the power of configuration injection, let's add another project called <code class="literal">tropicalFish</code> and add more behavior to the build via the build script of the <code class="literal">water</code> project.</p>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="ssub:filtering_by_name"></a>56.2.3.1. 按名称过滤</h4>
         <h6 class="title"><a name="ssub:filtering_by_name"></a>56.2.3.1.&nbsp;Filtering by name</h6>
        </div>
       </div>
      </div>
      <div class="example">
       <a name="multiprojectAddTropical"></a>
       <p class="title"><b>示例 56.8. 将自定义行为添加到某些项目中（按项目名称过滤） - Example&nbsp;56.8.&nbsp;Adding custom behaviour to some projects (filtered by project name)</b></p>
       <div class="example-contents">
        <p>构建布局<br>Build layout</p>
        <pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/
    build.gradle
  krill/
    build.gradle
  tropicalFish/</pre>
        <div class="exampleLocation">
         <p><span class="emphasis"><em>注︰</em> </span>此示例的代码可以在 Gradle 的二进制及源码分发包的 <code class="filename">samples/userguide/multiproject/addTropical/water</code> 中找到。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/addTropical/water</code> which is in both the binary and source distributions of Gradle.</p>
        </div>
        <p><code class="filename">settings.gradle</code></p>
        <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'bluewhale'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'krill'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'tropicalFish'</span></pre>
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">allprojects {
    task hello &lt;&lt; {task -&gt; println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"I'm $task.project.name"</span> }
}
subprojects {
    hello &lt;&lt; {println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- I depend on water"</span>}
}
configure(subprojects.findAll {it.name != <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'tropicalFish'</span>}) {
    hello &lt;&lt; {println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'- I love to spend time in the arctic waters.'</span>}
}</pre>
        <p><strong class="userinput"><code>gradle -q hello</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p>
        <pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I love to spend time in the arctic waters.
- I'm the largest animal that has ever lived on this planet.
I'm krill
- I depend on water
- I love to spend time in the arctic waters.
- The weight of my species in summer is twice as heavy as all human beings.
I'm tropicalFish
- I depend on water</pre>
       </div>
      </div>
      <br class="example-break">
      <p><code class="literal">configure()</code>方法接受一个 list 作为参数，并将配置应用到这个 list 里的项目。 <br>The <code class="literal">configure()</code> method takes a list as an argument and applies the configuration to the projects in this list.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="ssub:filtering_by_properties"></a>56.2.3.2. 通过属性过滤</h4>
         <h6 class="title"><a name="ssub:filtering_by_properties"></a>56.2.3.2.&nbsp;Filtering by properties</h6>
        </div>
       </div>
      </div>
      <p>我们可以选择使用项目的名称，或者是额外的项目属性来进行过滤。（请参阅《<a class="xref" href="writing_build_scripts.html#sec:extra_properties">第13.4.2节，额外属性</a> &gt;，以获取有关额外属性的更多信息。) <br>Using the project name for filtering is one option. Using extra project properties is another. (See <a class="xref" href="writing_build_scripts.html#sec:extra_properties">Section&nbsp;13.4.2, “Extra properties”</a> for more information on extra properties.)</p>
      <div class="example">
       <a name="multiprojectTropicalWithProperties"></a>
       <p class="title"><b>示例 56.9. 向某些项目添加自定义行为（按项目属性过滤） - Example&nbsp;56.9.&nbsp;Adding custom behaviour to some projects (filtered by project properties)</b></p>
       <div class="example-contents">
        <p>构建布局<br>Build layout</p>
        <pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/
    build.gradle
  krill/
    build.gradle
  tropicalFish/
    build.gradle</pre>
        <div class="exampleLocation">
         <p><span class="emphasis"><em>注︰</em> </span>此示例的代码可以在 Gradle 的二进制及源码分发包的 <code class="filename">samples/userguide/multiproject/tropicalWithProperties/water</code> 中找到。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/tropicalWithProperties/water</code> which is in both the binary and source distributions of Gradle.</p>
        </div>
        <p><code class="filename">settings.gradle</code></p>
        <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'bluewhale'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'krill'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'tropicalFish'</span></pre>
        <p><code class="filename">bluewhale/build.gradle</code></p>
        <pre class="programlisting">ext.arctic = true
hello.doLast { println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- I'm the largest animal that has ever lived on this planet."</span> }</pre>
        <p><code class="filename">krill/build.gradle</code></p>
        <pre class="programlisting">ext.arctic = true
hello.doLast {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- The weight of my species in summer is twice as heavy as all human beings."</span>
}</pre>
        <p><code class="filename">tropicalFish/build.gradle</code></p>
        <pre class="programlisting">ext.arctic = false</pre>
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">allprojects {
    task hello &lt;&lt; {task -&gt; println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"I'm $task.project.name"</span> }
}
subprojects {
    hello {
        doLast {println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- I depend on water"</span>}
        afterEvaluate { Project project -&gt;
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (project.arctic) { doLast {
                println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'- I love to spend time in the arctic waters.'</span> }
            }
        }
    }
}</pre>
        <p><strong class="userinput"><code>gradle -q hello</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p>
        <pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
- I love to spend time in the arctic waters.
I'm krill
- I depend on water
- The weight of my species in summer is twice as heavy as all human beings.
- I love to spend time in the arctic waters.
I'm tropicalFish
- I depend on water</pre>
       </div>
      </div>
      <br class="example-break">
      <p>在 <code class="literal">water</code> 项目的构建文件中，我们使用了一个 <code class="literal">afterEvaluate</code> 通知。这意味着，我们所传的闭包将在子项目的构建脚本评估<span class="emphasis"><em>之后</em></span>才进行评估。由于属性 <code class="literal">arctic</code> 设置在这些构建脚本中，所以我们必须这样做。在《<a class="xref" href="multi_project_builds.html#sec:dependencies_which_dependencies">第56.6节，依赖——哪些依赖？</a>》中，你可以看到更多有关这个主题的信息。 <br>In the build file of the <code class="literal">water</code> project we use an <code class="literal">afterEvaluate</code> notification. This means that the closure we are passing gets evaluated <span class="emphasis"><em>after</em></span> the build scripts of the subproject are evaluated. As the property <code class="literal">arctic</code> is set in those build scripts, we have to do it this way. You will find more on this topic in <a class="xref" href="multi_project_builds.html#sec:dependencies_which_dependencies">Section&nbsp;56.6, “Dependencies - Which dependencies?”</a></p>
     </div>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:execution_rules_for_multi_project_builds"></a>56.3.&nbsp;多项目构建的执行规则</h2>
       <h4 class="title"><a name="sec:execution_rules_for_multi_project_builds"></a>56.3.&nbsp;Execution rules for multi-project builds</h4>
      </div>
     </div>
    </div>
    <p>当我们从根项目目录执行了 <code class="literal">hello</code> 任务时，会以一种直观的方式表现出来。不同项目中的所有 <code class="literal">hello</code> 任务都被执行了。让我们切换到 <code class="literal">bluewhale</code> 目录，看看如果我们在那里执行 Gradle，会发生什么。 <br>When we have executed the <code class="literal">hello</code> task from the root project dir things behaved in an intuitive way. All the <code class="literal">hello</code> tasks of the different projects were executed. Let's switch to the <code class="literal">bluewhale</code> dir and see what happens if we execute Gradle from there.</p>
    <div class="example">
     <a name="multiprojectSubBuild"></a>
     <p class="title"><b>示例 56.10. 从子项目运行构建 - Example&nbsp;56.10.&nbsp;Running build from subproject</b></p>
     <div class="example-contents">
      <p><strong class="userinput"><code>gradle -q hello</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p>
      <pre class="screen">&gt; gradle -q hello
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
- I love to spend time in the arctic waters.</pre>
     </div>
    </div>
    <br class="example-break">
    <p>Gradle 的行为背后的基本规则很简单。Gradle 从<span class="emphasis"><em>当前目录</em></span>开始，按层次结构往下查找名为 <code class="literal">hello</code> 的任务并执行它们。有一件事很重要。Gradle <span class="emphasis"><em>始终</em></span>评估多项目构建的<span class="emphasis"><em>每一个</em></span>项目，并创建所有存在的任务对象。然后，根据任务名称参数和当前目录， Gradle 过滤出应该执行的任务。由于 Gradle 的跨项目配置，<span class="emphasis"><em>每个</em></span>项目都必须在执行<span class="emphasis"><em>任何</em></span>任务之前先评估。我们将在下一节仔细研究这一点。现在让我们看看最后一个 marine 的例子。 我们先将任务添加到 <code class="literal">bluewhale</code> 和 <code class="literal">krill</code>。 <br>The basic rule behind Gradle's behavior is simple. Gradle looks down the hierarchy, starting with the <span class="emphasis"><em>current dir</em></span>, for tasks with the name <code class="literal">hello</code> an executes them. One thing is very important to note. Gradle <span class="emphasis"><em>always</em></span> evaluates <span class="emphasis"><em>every</em></span> project of the multi-project build and creates all existing task objects. Then, according to the task name arguments and the current dir, Gradle filters the tasks which should be executed. Because of Gradle's cross project configuration <span class="emphasis"><em>every</em></span> project has to be evaluated before <span class="emphasis"><em>any</em></span> task gets executed. We will have a closer look at this in the next section. Let's now have our last marine example. Let's add a task to <code class="literal">bluewhale</code> and <code class="literal">krill</code>.</p>
    <div class="example">
     <a name="multiprojectPartialTasks"></a>
     <p class="title"><b>示例 56.11. 项目的评估和执行 - Example&nbsp;56.11.&nbsp;Evaluation and execution of projects</b></p>
     <div class="example-contents">
      <p><code class="filename">bluewhale/build.gradle</code></p>
      <pre class="programlisting">ext.arctic = true
hello &lt;&lt; { println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- I'm the largest animal that has ever lived on this planet."</span> }

task distanceToIceberg &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'20 nautical miles'</span>
}</pre>
      <p><code class="filename">krill/build.gradle</code></p>
      <pre class="programlisting">ext.arctic = true
hello &lt;&lt; { println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"- The weight of my species in summer is twice as heavy as all human beings."</span> }

task distanceToIceberg &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'5 nautical miles'</span>
}</pre>
      <p><strong class="userinput"><code>gradle -q distanceToIceberg</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q distanceToIceberg</code></strong></p>
      <pre class="screen">&gt; gradle -q distanceToIceberg
20 nautical miles
5 nautical miles</pre>
     </div>
    </div>
    <br class="example-break">
    <p>不使用 <code class="literal">-q</code> 选项的输出结果︰<br>Here the output without the <code class="literal">-q</code> option:</p>
    <div class="example">
     <a name="multiprojectPartialTasksNotQuiet"></a>
     <p class="title"><b>示例 56.12. 项目的评估和执行 - Example&nbsp;56.12.&nbsp;Evaluation and execution of projects</b></p>
     <div class="example-contents">
      <p><strong class="userinput"><code>gradle distanceToIceberg</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle distanceToIceberg</code></strong></p>
      <pre class="screen">&gt; gradle distanceToIceberg
:bluewhale:distanceToIceberg
20 nautical miles
:krill:distanceToIceberg
5 nautical miles

BUILD SUCCESSFUL

Total time: 1 secs</pre>
     </div>
    </div>
    <br class="example-break">
    <p>构建从 <code class="literal">water</code> 项目执行。<code class="literal">water</code> 和 <code class="literal">tropicalFish</code> 都没有一个叫 <code class="literal">distanceToIceberg</code>的任务，但 Gradle 不关心这个问题。上面提到的简单规则是：执行这个层次结构下叫这个名字的所有任务。如果<span class="emphasis"><em>没有</em></span>这样的任务，只能报错！ <br>The build is executed from the <code class="literal">water</code> project. Neither <code class="literal">water</code> nor <code class="literal">tropicalFish</code> have a task with the name <code class="literal">distanceToIceberg</code>. Gradle does not care. The simple rule mentioned already above is: Execute all tasks down the hierarchy which have this name. Only complain if there is <span class="emphasis"><em>no</em></span> such task!</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:running_partial_build_from_the_root"></a>56.4. 按绝对路径运行任务</h2>
       <h4 class="title"><a name="sec:running_partial_build_from_the_root"></a>56.4.&nbsp;Running tasks by their absolute path</h4>
      </div>
     </div>
    </div>
    <p>如我们所见，你可以通过进入任意的子项目目录并从该处执行构建来运行多项目构建。从当前目录开始的项目层次结构中，所有名字匹配的任务都会被执行。不过 Gradle 也提供了按绝对路径来执行任务的方式（另请参阅《<a class="xref" href="multi_project_builds.html#sec:project_and_task_paths">第56.5节，项目和任务路径</a>》）： <br>As we have seen, you can run a multi-project build by entering any subproject dir and execute the build from there. All matching task names of the project hierarchy starting with the current dir are executed. But Gradle also offers to execute tasks by their absolute path (see also <a class="xref" href="multi_project_builds.html#sec:project_and_task_paths">Section&nbsp;56.5, “Project and task paths”</a>):</p>
    <div class="example">
     <a name="multiprojectAbsoluteTaskPaths"></a>
     <p class="title"><b>示例 56.13. 按绝对路径运行任务 - Example&nbsp;56.13.&nbsp;Running tasks by their absolute path</b></p>
     <div class="example-contents">
      <p><strong class="userinput"><code>gradle -q :hello :krill:hello hello</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q :hello :krill:hello hello</code></strong></p>
      <pre class="screen">&gt; gradle -q :hello :krill:hello hello
I'm water
I'm krill
- I depend on water
- The weight of my species in summer is twice as heavy as all human beings.
- I love to spend time in the arctic waters.
I'm tropicalFish
- I depend on water</pre>
     </div>
    </div>
    <br class="example-break">
    <p>构建从 <code class="literal">tropicalFish</code> 项目执行。我们执行了 <code class="literal">water</code>， <code class="literal">hello</code> 及 <code class="literal">tropicalFish</code> 这三个项目的 <code class="literal">hello</code> 任务。 前两个任务由其绝对路径指定，最后一个任务通过上面所述的名称匹配机制执行。 <br>The build is executed from the <code class="literal">tropicalFish</code> project. We execute the <code class="literal">hello</code> tasks of the <code class="literal">water</code>, the <code class="literal">krill</code> and the <code class="literal">tropicalFish</code> project. The first two tasks are specified by there absolute path, the last task is executed on the name matching mechanism described above.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:project_and_task_paths"></a>56.5. 项目和任务路径</h2>
       <h4 class="title"><a name="sec:project_and_task_paths"></a>56.5.&nbsp;Project and task paths</h4>
      </div>
     </div>
    </div>
    <p>项目路径具有以下模式：它始终以冒号开头，表示根项目。根项目是路径中唯一不由其名称指定的项目。路径 <code class="literal">:bluewhale</code> 对应于上面示例中的文件系统路径 <code class="literal">water/bluewhale</code> 。 <br>A project path has the following pattern: It starts always with a colon, which denotes the root project. The root project is the only project in a path that is not specified by its name. The path <code class="literal">:bluewhale</code> corresponds to the file system path <code class="literal">water/bluewhale</code> in the case of the example above.</p>
    <p>任务的路径只是它的项目路径加上任务名称。 例如 <code class="literal"> :bluewhale:hello</code>。在项目中，您可以通过任务的名称来处理同一项目的任务，这被解释为相对路径。 <br>The path of a task is simply its project path plus the task name. For example <code class="literal"> :bluewhale:hello</code>. Within a project you can address a task of the same project just by its name. This is interpreted as a relative path.</p>
    <p>最初 Gradle 使用 <code class="literal">“/”</code> 字符作为自然路径分隔符。在引入目录任务（见《<a class="xref" href="tutorial_this_and_that.html#sec:directory_creation">第14.1节，目录创建</a>)》就不能再这样做了，因为目录任务的名称包含 <code class="literal">“/”</code> 字符。 <br>Originally Gradle has used the <code class="literal">'/'</code> character as a natural path separator. With the introduction of directory tasks (see <a class="xref" href="tutorial_this_and_that.html#sec:directory_creation">Section&nbsp;14.1, “Directory creation”</a>) this was no longer possible, as the name of the directory task contains the <code class="literal">'/'</code> character.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:dependencies_which_dependencies"></a>56.6. 依赖——哪些依赖？</h2>
       <h4 class="title"><a name="sec:dependencies_which_dependencies"></a>56.6.&nbsp;Dependencies - Which dependencies?</h4>
      </div>
     </div>
    </div>
    <p>上一节的例子比较特殊，因为项目里没有<span class="emphasis"><em>执行依赖</em></span>，只有<span class="emphasis"><em>配置依赖</em></span>。下面是一个不同的例子： <br>The examples from the last section were special, as the projects had no <span class="emphasis"><em>Execution Dependencies</em></span>. They had only <span class="emphasis"><em>Configuration Dependencies</em></span>. Here is an example where this is different:</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:execution_time_dependencies"></a>56.6.1.&nbsp;执行依赖</h3>
        <h5 class="title"><a name="sub:execution_time_dependencies"></a>56.6.1.&nbsp;Execution dependencies</h5>
       </div>
      </div>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="ssub:dependencies_and_execution_order"></a>56.6.1.1.&nbsp;依赖和执行顺序</h4>
         <h6 class="title"><a name="ssub:dependencies_and_execution_order"></a>56.6.1.1.&nbsp;Dependencies and execution order</h6>
        </div>
       </div>
      </div>
      <div class="example">
       <a name="multiprojectFirstMessages"></a>
       <p class="title"><b>示例 56.14.&nbsp;依赖和执行顺序 - Example&nbsp;56.14.&nbsp;Dependencies and execution order</b></p>
       <div class="example-contents">
        <p>构建布局<br>Build layout</p>
        <pre class="programlisting">messages/
  settings.gradle
  consumer/
    build.gradle
  producer/
    build.gradle</pre>
        <div class="exampleLocation">
         <p><span class="emphasis"><em>注︰</em> </span>此示例的代码可以在 Gradle 二进制和源码分发包的 <code class="filename">samples/userguide/multiproject/dependencies/firstMessages/messages</code> 中找到。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/dependencies/firstMessages/messages</code> which is in both the binary and source distributions of Gradle.</p>
        </div>
        <p><code class="filename">settings.gradle</code></p>
        <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'consumer'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'producer'</span></pre>
        <p><code class="filename">consumer/build.gradle</code></p>
        <pre class="programlisting">task action &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
}</pre>
        <p><code class="filename">producer/build.gradle</code></p>
        <pre class="programlisting">task action &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Producing message:"</span>
    rootProject.producerMessage = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'Watch the order of execution.'</span>
}</pre>
        <p><strong class="userinput"><code>gradle -q action</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q action</code></strong></p>
        <pre class="screen">&gt; gradle -q action
Consuming message: null
Producing message:</pre>
       </div>
      </div>
      <br class="example-break">
      <p>它并没有成功。如果没有定义别的，那么 Gradle 将按字母数字的顺序执行任务。因此，<code class="literal">:consumer:action</code> 会在 <code class="literal">:producter:action</code> 之前执行 。 让我们尝试用一个技巧来解决这个问题，并将生产者项目重命名为 <code class="literal">aProducer</code>。 <br>This did not work out. If nothing else is defined, Gradle executes the task in alphanumeric order. Therefore <code class="literal">:consumer:action</code> is executed before <code class="literal">:producer:action</code>. Let's try to solve this with a hack and rename the producer project to <code class="literal">aProducer</code>.</p>
      <div class="example">
       <a name="multiprojectMessagesHack"></a>
       <p class="title"><b>示例 56.15.&nbsp;依赖和执行顺序 - Example&nbsp;56.15.&nbsp;Dependencies and execution order</b></p>
       <div class="example-contents">
        <p>构建布局<br>Build layout</p>
        <pre class="programlisting">messages/
  settings.gradle
  aProducer/
    build.gradle
  consumer/
    build.gradle</pre>
        <p><code class="filename">settings.gradle</code></p>
        <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'consumer'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'aProducer'</span></pre>
        <p><code class="filename">aProducer/build.gradle</code></p>
        <pre class="programlisting">task action &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Producing message:"</span>
    rootProject.producerMessage = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'Watch the order of execution.'</span>
}</pre>
        <p><code class="filename">consumer/build.gradle</code></p>
        <pre class="programlisting">task action &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
}</pre>
        <p><strong class="userinput"><code>gradle -q action</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q action</code></strong></p>
        <pre class="screen">&gt; gradle -q action
Producing message:
Consuming message: Watch the order of execution.</pre>
       </div>
      </div>
      <br class="example-break">
      <p>现在我们来看这个技巧。我们简单地切换到 <code class="literal">consumer</code> 目录并执行构建。 <br>Now we take the air out of this hack. We simply switch to the <code class="literal">consumer</code> dir and execute the build.</p>
      <div class="example">
       <a name="multiprojectMessagesHackBroken"></a>
       <p class="title"><b>示例 56.16.&nbsp;依赖和执行顺序 - Example&nbsp;56.16.&nbsp;Dependencies and execution order</b></p>
       <div class="example-contents">
        <p><strong class="userinput"><code>gradle -q action</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q action</code></strong></p>
        <pre class="screen">&gt; gradle -q action
Consuming message: null</pre>
       </div>
      </div>
      <br class="example-break">
      <p>对于 Gradle 而言，这两个 <code class="literal">action</code> 任务没有关联。如果你从 <code class="literal">messages</code> 项目执行构建，Gradle 将同时执行它们两个，因为它们有相同的名称并且都在层次结构下。在最后一个示例中，只有一个 <code class="literal">action</code> 是在这个层次结构下，因此它是唯一一个被执行的任务。我们需要比这种方式更好的实现。 <br>For Gradle the two <code class="literal">action</code> tasks are just not related. If you execute the build from the <code class="literal">messages</code> project Gradle executes them both because they have the same name and they are down the hierarchy. In the last example only one <code class="literal">action</code> was down the hierarchy and therefore it was the only task that got executed. We need something better than this hack.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="ssub:declaring_dependencies"></a>56.6.1.2. 声明依赖</h4>
         <h6 class="title"><a name="ssub:declaring_dependencies"></a>56.6.1.2.&nbsp;Declaring dependencies</h6>
        </div>
       </div>
      </div>
      <div class="example">
       <a name="multiprojectMessagesDependencies"></a>
       <p class="title"><b>示例 56.17. 声明依赖 - Example&nbsp;56.17.&nbsp;Declaring dependencies</b></p>
       <div class="example-contents">
        <p>构建布局<br>Build layout</p>
        <pre class="programlisting">messages/
  settings.gradle
  consumer/
    build.gradle
  producer/
    build.gradle</pre>
        <div class="exampleLocation">
         <p><span class="emphasis"><em>注︰</em> </span>此示例的代码可以在 Gradle 二进制和源码分发包的 <code class="filename">samples/userguide/multiproject/dependencies/messagesWithDependencies/messages</code> 中找到。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/dependencies/messagesWithDependencies/messages</code> which is in both the binary and source distributions of Gradle.</p>
        </div>
        <p><code class="filename">settings.gradle</code></p>
        <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'consumer'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'producer'</span></pre>
        <p><code class="filename">consumer/build.gradle</code></p>
        <pre class="programlisting">task action(dependsOn: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":producer:action"</span>) &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
}</pre>
        <p><code class="filename">producer/build.gradle</code></p>
        <pre class="programlisting">task action &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Producing message:"</span>
    rootProject.producerMessage = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'Watch the order of execution.'</span>
}</pre>
        <p><strong class="userinput"><code>gradle -q action</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q action</code></strong></p>
        <pre class="screen">&gt; gradle -q action
Producing message:
Consuming message: Watch the order of execution.</pre>
       </div>
      </div>
      <br class="example-break">
      <p>从<code class="literal">consumer</code>目录运行将得到：<br>Running this from the <code class="literal">consumer</code> directory gives:</p>
      <div class="example">
       <a name="multiprojectMessagesDependenciesSubBuild"></a>
       <p class="title"><b>示例 56.18. 声明依赖 - Example&nbsp;56.18.&nbsp;Declaring dependencies</b></p>
       <div class="example-contents">
        <p><strong class="userinput"><code>gradle -q action</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q action</code></strong></p>
        <pre class="screen">&gt; gradle -q action
Producing message:
Consuming message: Watch the order of execution.</pre>
       </div>
      </div>
      <br class="example-break">
      <p>我们现在声明了 <code class="literal">consumer</code> 项目的 <code class="literal">action</code> 任务对 <code class="literal">producer</code> 项目的 <code class="literal">action</code> 任务有<span class="emphasis"><em>执行依赖</em></span>。 <br>We have now declared that the <code class="literal">action</code> task in the <code class="literal">consumer</code> project has an <span class="emphasis"><em>execution dependency</em></span> on the <code class="literal">action</code> task on the <code class="literal">producer</code> project.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="ssub:the_nature_of_cross_project_task_dependencies"></a>56.6.1.3.&nbsp;跨项目任务依赖的本质</h4>
         <h6 class="title"><a name="ssub:the_nature_of_cross_project_task_dependencies"></a>56.6.1.3.&nbsp;The nature of cross project task dependencies</h6>
        </div>
       </div>
      </div>
      <p>当然，不同项目之间的任务依赖并不局限于名字相同。让我们更改任务名并执行构建。 <br>Of course, task dependencies across different projects are not limited to tasks with the same name. Let's change the naming of our tasks and execute the build.</p>
      <div class="example">
       <a name="multiprojectMessagesTaskDependencies"></a>
       <p class="title"><b>示例 56.19.&nbsp;跨项目任务依赖 - Example&nbsp;56.19.&nbsp;Cross project task dependencies</b></p>
       <div class="example-contents">
        <p><code class="filename">consumer/build.gradle</code></p>
        <pre class="programlisting">task consume(dependsOn: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':producer:produce'</span>) &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
}</pre>
        <p><code class="filename">producer/build.gradle</code></p>
        <pre class="programlisting">task produce &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Producing message:"</span>
    rootProject.producerMessage = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'Watch the order of execution.'</span>
}</pre>
        <p><strong class="userinput"><code>gradle -q consume</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q consume</code></strong></p>
        <pre class="screen">&gt; gradle -q consume
Producing message:
Consuming message: Watch the order of execution.</pre>
       </div>
      </div>
      <br class="example-break">
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:configuration_time_dependencies"></a>56.6.2.&nbsp;配置时依赖</h3>
        <h5 class="title"><a name="sub:configuration_time_dependencies"></a>56.6.2.&nbsp;Configuration time dependencies</h5>
       </div>
      </div>
     </div>
     <p>在进入 <span class="emphasis"><em>Java</em></span> 领域之前，让我们再使用生产者——消费者构建的例子。我们添加一个属性到生产者项目，并且现在创建一个消费者对生产者的配置时间依赖。 <br>Let's have one more example with our producer-consumer build before we enter <span class="emphasis"><em>Java</em></span> land. We add a property to the producer project and create now a configuration time dependency from consumer on producer.</p>
     <div class="example">
      <a name="multiprojectMessagesConfigDependenciesBroken"></a>
      <p class="title"><b>示例 56.20.&nbsp;配置时依赖 - Example&nbsp;56.20.&nbsp;Configuration time dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">consumer/build.gradle</code></p>
       <pre class="programlisting">def message = rootProject.producerMessage

task consume &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Consuming message: "</span> + message)
}</pre>
       <p><code class="filename">producer/build.gradle</code></p>
       <pre class="programlisting">rootProject.producerMessage = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'Watch the order of evaluation.'</span></pre>
       <p><strong class="userinput"><code>gradle -q consume</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q consume</code></strong></p>
       <pre class="screen">&gt; gradle -q consume
Consuming message: null</pre>
      </div>
     </div>
     <br class="example-break">
     <p>项目的默认<span class="emphasis"><em>评估</em></span>顺序是字母数字（对于同一嵌套级别）。因此，<code class="literal">consumer</code> 项目评估会在 <code class="literal">producer</code> 项目之前，并且 <code class="literal">producer</code> 的 <code class="literal">key</code> 值在它被 <code class="literal">consumer</code> 项目读取<span class="emphasis"><em>之后</em></span>设置。Gradle 为此提供了一个解决方案。 <br>The default <span class="emphasis"><em>evaluation</em></span> order of the projects is alphanumeric (for the same nesting level). Therefore the <code class="literal">consumer</code> project is evaluated before the <code class="literal">producer</code> project and the <code class="literal">key</code> value of the <code class="literal">producer</code> is set <span class="emphasis"><em>after</em></span> it is read by the <code class="literal">consumer</code> project. Gradle offers a solution for this.</p>
     <div class="example">
      <a name="multiprojectMessagesConfigDependencies"></a>
      <p class="title"><b>示例 56.21. 配置时依赖——evaluationDependsOn - Example&nbsp;56.21.&nbsp;Configuration time dependencies - evaluationDependsOn</b></p>
      <div class="example-contents">
       <p><code class="filename">consumer/build.gradle</code></p>
       <pre class="programlisting">evaluationDependsOn(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':producer'</span>)

def message = rootProject.producerMessage

task consume &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Consuming message: "</span> + message)
}</pre>
       <p><strong class="userinput"><code>gradle -q consume</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q consume</code></strong></p>
       <pre class="screen">&gt; gradle -q consume
Consuming message: Watch the order of evaluation.</pre>
      </div>
     </div>
     <br class="example-break">
     <p>命令 <code class="literal">evaluationDependsOn</code> 触发 <code class="literal">producer</code> 在 <code class="literal">consumer</code> <span class="emphasis"><em>之前</em></span> 进行评估。这个例子是特意展示这个机制的。<span class="emphasis"><em>这种</em></span>情况下，通过在执行时读取关键属性，会是一种更简单的解决方案。 <br>The command <code class="literal">evaluationDependsOn</code> triggers the evaluation of <code class="literal">producer</code> <span class="emphasis"><em>before</em></span> <code class="literal">consumer</code> is evaluated. The example is a bit contrived for the sake of showing the mechanism. In <span class="emphasis"><em>this</em></span> case there would be an easier solution by reading the key property at execution time.</p>
     <div class="example">
      <a name="multiprojectMessagesConfigDependenciesAltSolution"></a>
      <p class="title"><b>示例 56.22.&nbsp;配置时依赖 - Example&nbsp;56.22.&nbsp;Configuration time dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">consumer/build.gradle</code></p>
       <pre class="programlisting">task consume &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
}</pre>
       <p><strong class="userinput"><code>gradle -q consume</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q consume</code></strong></p>
       <pre class="screen">&gt; gradle -q consume
Consuming message: Watch the order of evaluation.</pre>
      </div>
     </div>
     <br class="example-break">
     <p>配置依赖与执行依赖有很大不同。配置依赖是项目之间的，而执行依赖则总是被解析为任务依赖。另一个区别是，所有项目总是都会被配置，即使你是从子项目启动构建的。默认的配置顺序是通常所需要的从顶至下的顺序。 <br>Configuration dependencies are very different to execution dependencies. Configuration dependencies are between projects whereas execution dependencies are always resolved to task dependencies. Another difference is that always all projects are configured, even when you start the build from a subproject. The default configuration order is top down, which is usually what is needed.</p>
     <p> 如果要把默认配置的顺序改为从下到上，这意味着一个项目的配置将会依赖于它的子项目的配置，可以使用 <code class="literal">evaluationDependsOnChildren()</code> 方法。 <br>To change the the default configuration order to be bottom up, That means that a project configuration depends on the configuration of its child projects, the <code class="literal">evaluationDependsOnChildren()</code> method can be used.</p>
     <p>嵌套级别相同时，配置顺序取决于字母数字位置。最常见的用例是共享公共生命周期的多项目构建（例如，所有项目都使用 Java 插件）。如果通过 <code class="literal"><span class="emphasis">dependsOn</span></code><span class="emphasis"> 声明了不同项目之间的<em>执行依赖</em></span>，该方法的默认行为也会创建两个项目之间的<span class="emphasis"><em>配置</em></span>依赖。因此，你可能不需要显式定义配置依赖。 <br>On the same nesting level the configuration order depends on the alphanumeric position. The most common use case is to have multi-project builds that share a common lifecycle (e.g. all projects use the Java plugin). If you declare with <code class="literal">dependsOn</code> a <span class="emphasis"><em>execution dependency</em></span> between different projects, the default behavior of this method is to create also a <span class="emphasis"><em>configuration</em></span> dependency between the two projects. Therefore it is likely that you don't have to define configuration dependencies explicitly.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:real_life_examples"></a>56.6.3.&nbsp;真实生活示例</h3>
        <h5 class="title"><a name="sub:real_life_examples"></a>56.6.3.&nbsp;Real life examples</h5>
       </div>
      </div>
     </div>
     <p>Gradle 的多项目功能是由真实生活用例所驱动的。描述这种用例的第一个示例包括了两个 webapplication 项目，以及一个创建分发的父项目。<sup>[<a href="#ftn.N16354" name="N16354" class="footnote">21</a>]</sup> 对于这个例子，我们只使用一个构建脚本，并执行<span class="emphasis"><em>跨项目配置</em></span>。 <br>Gradle's multi-project features are driven by real life use cases. The first example for describing such a use case, consists of two webapplication projects and a parent project that creates a distribution out of them. <sup>[<a href="#ftn.N16354" name="N16354" class="footnote">21</a>]</sup> For the example we use only one build script and do <span class="emphasis"><em>cross project configuration</em></span>.</p>
     <div class="example">
      <a name="webdist"></a>
      <p class="title"><b>示例 56.23. 依赖——真实生活示例——跨项目配置 - Example&nbsp;56.23.&nbsp;Dependencies - real life example - crossproject configuration</b></p>
      <div class="example-contents">
       <p>构建布局<br>Build layout</p>
       <pre class="programlisting">webDist/
  settings.gradle
  build.gradle
  date/
    src/main/java/
      org/gradle/sample/
        DateServlet.java
  hello/
    src/main/java/
      org/gradle/sample/
        HelloServlet.java</pre>
       <div class="exampleLocation">
        <p><span class="emphasis"><em>注︰</em> </span>此示例的代码可以在 Gradle 二进制和源码分发包的 <code class="filename">samples/userguide/multiproject/dependencies/webDist/messages</code> 中找到。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/dependencies/webDist</code> which is in both the binary and source distributions of Gradle.</p>
       </div>
       <p><code class="filename">settings.gradle</code></p>
       <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'date'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span></pre>
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">allprojects {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'java'</span>
    group = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle.sample'</span>
    version = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.0'</span>
}

subprojects {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'war'</span>
    repositories {
        mavenCentral()
}
    }
    dependencies {
        compile <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"javax.servlet:servlet-api:2.5"</span>
    }
}

task explodedDist(dependsOn: assemble) &lt;&lt; {
    File explodedDist = mkdir(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$buildDir/explodedDist"</span>)
    subprojects.each {project -&gt;
        project.tasks.withType(Jar).each {archiveTask -&gt;
            copy {
                from archiveTask.archivePath
                into explodedDist
            }
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>我们有一套有意思的依赖。显然，<code class="literal">date</code> 和 <code class="literal">hello</code> 项目都对 <code class="literal">webDist</code> 有<span class="emphasis"><em>配置</em></span>依赖，因为 web 应用程序项目的所有构建逻辑都由 <code class="literal">webDist</code> 注入。<span class="emphasis"><em>执行</em></span>依赖则反过来，因为 <code class="literal">webDist</code> 依赖于 <code class="literal">date</code> 和 <code class="literal">hello</code> 的构建工件。这里甚至还有第三个依赖。<code class="literal">webDist</code> 对 <code class="literal">date</code> 和 <code class="literal">hello</code> 有<span class="emphasis"><em>配置</em></span>依赖，因为它需要知道 <code class="literal">archivePath</code>。但是，它会在<span class="emphasis"><em>执行时</em></span>才要求提供该信息。因此，我们没有循环依赖。 <br>We have an interesting set of dependencies. Obviously the <code class="literal">date</code> and <code class="literal">hello</code> projects have a <span class="emphasis"><em>configuration</em></span> dependency on <code class="literal">webDist</code>, as all the build logic for the webapp projects is injected by <code class="literal">webDist</code>. The <span class="emphasis"><em>execution</em></span> dependency is in the other direction, as <code class="literal">webDist</code> depends on the build artifacts of <code class="literal">date</code> and <code class="literal">hello</code>. There is even a third dependency. <code class="literal">webDist</code> has a <span class="emphasis"><em>configuration</em></span> dependency on <code class="literal">date</code> and <code class="literal">hello</code> because it needs to know the <code class="literal">archivePath</code>. But it asks for this information at <span class="emphasis"><em>execution time</em></span>. Therefore we have no circular dependency.</p>
     <p>在多项目构建中，这样的或其他的依赖模式是很常见的。如果一个构建系统不支持这种模式，那你要么无法解决问题，要么需要用一些恶心的 hack 方法，这样就会很难维护，并且作为构建分支将严重影响你的生产力。 <br>Such and other dependency patterns are daily bread in the problem space of multi-project builds. If a build system does not support such patterns, you either can't solve your problem or you need to do ugly hacks which are hard to maintain and massively afflict your productivity as a build master.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:project_jar_dependencies"></a>56.7.&nbsp;项目库依赖</h2>
       <h4 class="title"><a name="sec:project_jar_dependencies"></a>56.7.&nbsp;Project lib dependencies</h4>
      </div>
     </div>
    </div>
    <p>如果一个项目在其编译路径上需要另一个项目生成的 jar 呢？并且不仅是 jar，还有它的传递依赖呢？显然，这是 Java 多项目构建中非常常见的情况。如《<a class="xref" href="dependency_management.html#sub:project_dependencies">第50.4.3节，项目依赖</a>》中所述，Gradle 为此提供了项目库依赖。 <br>What if one projects needs the jar produced by another project in its compile path? And not just the jar but also the transitive dependencies of this jar? Obviously this is a very common use case for Java multi-project builds. As already mentioned in <a class="xref" href="dependency_management.html#sub:project_dependencies">Section&nbsp;50.4.3, “Project dependencies”</a>, Gradle offers project lib dependencies for this.</p>
    <div class="example">
     <a name="javadependencies_1"></a>
     <p class="title"><b>示例 56.24.&nbsp;项目库依赖 - Example&nbsp;56.24.&nbsp;Project lib dependencies</b></p>
     <div class="example-contents">
      <p>构建布局<br>Build layout</p>
      <pre class="programlisting">java/
  settings.gradle
  build.gradle
  api/
    src/main/java/
      org/gradle/sample/
        api/
          Person.java
        apiImpl/
          PersonImpl.java
  services/personService/
    src/
      main/java/
        org/gradle/sample/services/
          PersonService.java
      test/java/
        org/gradle/sample/services/
          PersonServiceTest.java
  shared/
    src/main/java/
      org/gradle/sample/shared/
        Helper.java</pre>
      <div class="exampleLocation">
       <p><span class="emphasis"><em>注︰</em> </span>此示例的代码可以在 Gradle 二进制和源码分发包的 <code class="filename">samples/userguide/multiproject/dependencies/java/messages</code> 中找到。<br><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/dependencies/java</code> which is in both the binary and source distributions of Gradle.</p>
      </div>
     </div>
    </div>
    <br class="example-break">
    <p>我们有这些项目：<code class="literal">shared</code>，<code class="literal">api</code> 和 <code class="literal">personService</code>。<code class="literal">personService</code> 对其他两个项目有一个库依赖，<code class="literal">api</code> 对 <code class="literal">shared</code>上有一个库依赖。<sup>[<a href="#ftn.N163DA" name="N163DA" class="footnote">22</a>]</sup> <br>We have the projects <code class="literal">shared</code>, <code class="literal">api</code> and<code class="literal">personService</code>. <code class="literal">personService</code> has a lib dependency on the other two projects. <code class="literal">api</code> has a lib dependency on <code class="literal">shared</code>. <sup>[<a href="#ftn.N163DA" name="N163DA" class="footnote">22</a>]</sup></p>
    <div class="example">
     <a name="javadependencies_2"></a>
     <p class="title"><b>示例 56.25.&nbsp;项目库依赖 - Example&nbsp;56.25.&nbsp;Project lib dependencies</b></p>
     <div class="example-contents">
      <p><code class="filename">settings.gradle</code></p>
      <pre class="programlisting">include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'api'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'shared'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'services:personService'</span></pre>
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">subprojects {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'java'</span>
    group = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle.sample'</span>
    version = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.0'</span>
    repositories {
        mavenCentral()
}
    }
    dependencies {
        testCompile <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"junit:junit:4.11"</span>
    }
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':api'</span>) {
    dependencies {
        compile project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':shared'</span>)
    }
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':services:personService'</span>) {
    dependencies {
        compile project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':shared'</span>), project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':api'</span>)
    }
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p>所有构建逻辑都在根项目的 <code class="literal">build.gradle</code> 中。 <sup>[<a href="#ftn.N163F6" name="N163F6" class="footnote">23</a>]</sup><span class="emphasis"><em>库</em></span>依赖是执行依赖的一种特殊形式。它会首先构建另一个项目，并把其他项目的 jar 文件和类一起添加到类路径中。它还将其他项目的依赖也添加到类路径。因此你可以进入 <code class="literal">api</code> 目录并触发 <strong class="userinput"><code>gradle compile</code></strong>。首先构建 <code class="literal">shared</code>，然后构建 <code class="literal">api</code>。项目依赖支持部分多项目构建。 <br>All the build logic is in the <code class="literal">build.gradle</code> of the root project. <sup>[<a href="#ftn.N163F6" name="N163F6" class="footnote">23</a>]</sup> A <span class="emphasis"><em>lib</em></span> dependency is a special form of an execution dependency. It causes the other project to be built first and adds the jar with the classes of the other project to the classpath. It also adds the dependencies of the other project to the classpath. So you can enter the <code class="literal">api</code> directory and trigger a <strong class="userinput"><code>gradle compile</code></strong>. First <code class="literal">shared</code> is built and then <code class="literal">api</code> is built. Project dependencies enable partial multi-project builds.</p>
    <p>如果你是从 Maven 转过来的，你会对这一点很满意的。如果你是从 Ivy 转过来，你可能还想要一些更细粒度的控制。Gradle 向你提供了这种控制： <br>If you come from Maven land you might be perfectly happy with this. If you come from Ivy land, you might expect some more fine grained control. Gradle offers this to you:</p>
    <div class="example">
     <a name="javaWithCustomConf"></a>
     <p class="title"><b>示例 56.26. 对依赖的细粒度控制 - Example&nbsp;56.26.&nbsp;Fine grained control over dependencies</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">subprojects {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'java'</span>
    group = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle.sample'</span>
    version = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.0'</span>
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':api'</span>) {
    configurations {
        spi
    }
    dependencies {
        compile project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':shared'</span>)
    }
    task spiJar(type: Jar) {
        baseName = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'api-spi'</span>
        dependsOn classes
        from sourceSets.main.output
        include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org/gradle/sample/api/**'</span>)
    }
    artifacts {
        spi spiJar
    }
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':services:personService'</span>) {
    dependencies {
        compile project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':shared'</span>)
        compile project(path: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':api'</span>, configuration: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spi'</span>)
        testCompile <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"junit:junit:4.11"</span>, project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':api'</span>)
    }
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p>Java 插件将每个默认的 jar 添加到包含所有类的项目库中。在这个例子中，我们创建了一个<span class="emphasis"><em>额外的</em></span>库，它只包含 <code class="literal">api</code> 项目的接口。 我们把这个库指定给一个新的<span class="emphasis"><em>依赖配置</em></span>。对于 person service，我们声明这个项目应该只针对 <code class="literal">api</code> 接口进行编译，但使用 <code class="literal">api</code> 中的所有类进行测试。 <br>The Java plugin adds per default a jar to your project libraries which contains all the classes. In this example we create an <span class="emphasis"><em>additional</em></span> library containing only the interfaces of the <code class="literal">api</code> project. We assign this library to a new <span class="emphasis"><em>dependency configuration</em></span>. For the person service we declare that the project should be compiled only against the <code class="literal">api</code> interfaces but tested with all classes from <code class="literal">api</code>.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="disable_dependency_projects"></a>56.7.1.&nbsp;禁用依赖项目的构建</h3>
        <h5 class="title"><a name="disable_dependency_projects"></a>56.7.1.&nbsp;Disabling the build of dependency projects</h5>
       </div>
      </div>
     </div>
     <p>有时在进行局部构建的时候，你不希望依赖的项目也进行构建。如果想禁用依赖项目的构建，可以在运行 Gradle 的时候使用 <code class="code">-a</code> 选项。 <br>Sometimes you don't want depended on projects to be built when doing a partial build. To disable the build of the depended on projects you can run Gradle with the <code class="code">-a</code> option.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:parallel_execution"></a>56.8.&nbsp;并行项目执行</h2>
       <h4 class="title"><a name="sec:parallel_execution"></a>56.8.&nbsp;Parallel project execution</h4>
      </div>
     </div>
    </div>
    <p>随着在开发人员的台式机和 CI 服务器上，有越来越多的 CPU 内核可用，Gradle 能够充分利用这些处理资源就很重要。更具体地说，并行执行将尝试： <br>With more and more CPU cores available on developer desktops and CI servers, it is important that Gradle is able to fully utilise these processing resources. More specifically, the parallel execution attempts to:</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem">通过让执行进行 IO 绑定，或者是其他不消耗所有可用资源的方式，减少多项目构建的总构建时间。<br>Reduce total build time for a multi-project build where execution is IO bound or otherwise does not consume all available CPU resources.</li>
      <li class="listitem">更快地反馈小项目的执行，而不必等待其他项目的完成。<br>Provide faster feedback for execution of small projects without awaiting completion of other projects.</li>
     </ul>
    </div>
    <p> 虽然 Gradle 已通过 <a class="ulink" href="../javadoc/org/gradle/api/tasks/testing/Test.html#setMaxParallelForks(int)" target="_top"><code class="classname">Test.setMaxParallelForks()</code></a> 提供了并行测试执行，本节中描述的功能是项目级别的并行执行。并行执行是一个实验性的功能，请使用它，并让我们知道它是如何为你处理的。 <br>Although Gradle already offers parallel test execution via <a class="ulink" href="../javadoc/org/gradle/api/tasks/testing/Test.html#setMaxParallelForks(int)" target="_top"><code class="classname">Test.setMaxParallelForks()</code></a> the feature described in this section is parallel execution at a project level. Parallel execution is an incubating feature. Please use it and let us know how it works for you.</p>
    <p> 并行项目执行允许在一个解耦的多项目构建中的一些单独项目并行执行（另请参阅《<a class="xref" href="multi_project_builds.html#sec:decoupled_projects">第56.9节，解耦项目</a>》）。虽然并行执行并不严格要求在配置时进行解耦，但它的长期目标是提供一组强大的功能部件，用于完全解耦项目。这些功能包括： <br>Parallel project execution allows the separate projects in a decoupled multi-project build to be executed in parallel (see also: <a class="xref" href="multi_project_builds.html#sec:decoupled_projects">Section&nbsp;56.9, “Decoupled Projects”</a>). While parallel execution does not strictly require decoupling at configuration time, the long-term goal is to provide a powerful set of features that will be available for fully decoupled projects. Such features include:</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><a class="xref" href="multi_project_builds.html#sec:configuration_on_demand">第 56.1.1.1 节，“按需配置”</a>。<br><a class="xref" href="multi_project_builds.html#sec:configuration_on_demand">Section&nbsp;56.1.1.1, “Configuration on demand”</a>.</li>
      <li class="listitem">并行配置项目。<br>Configuration of projects in parallel.</li>
      <li class="listitem">对不变的项目复用配置。<br>Re-use of configuration for unchanged projects.</li>
      <li class="listitem">项目级别的最新检查。<br>Project-level up-to-date checks.</li>
      <li class="listitem">在构建依赖项目时使用预构建的工件。<br>Using pre-built artifacts in the place of building dependent projects.</li>
     </ul>
    </div>
    <p> </p>
    <p> 并行执行是怎么做的？首先，你需要告诉 Gradle 使用并行模式。你可以使用命令行参数（《<a class="xref" href="gradle_command_line.html">附录D，<i>Gradle 命令行</i></a>》），或者是配置你的构建环境（《<a class="xref" href="build_environment.html#sec:gradle_configuration_properties">第20.1节，通过 gradle.properties 配置构建环境</a>》）。除非你指定并行线程的个数，否则 Gradle 将根据可用的 CPU 内核来选择正确的线程数。当执行一个任务时，每个并行的工作线程都专用于一个给定的项目。这意味着同一项目中的两个任务永远不会并行执行。因此，只有多项目构建可以利用并行执行。并行执行完全支持任务依赖，并且并行线程将首先开始执行上游任务。记住，解耦的任务按字母顺序调度，且顺序执行，并不是真正的以并行模式执行。你需要确保正确声明了任务依赖，以避免排序问题。 <br>How does the parallel execution work? First, you need to tell Gradle to use the parallel mode. You can use the command line argument (<a class="xref" href="gradle_command_line.html">Appendix&nbsp;D, <i>Gradle Command Line</i></a>) or configure your build environment (<a class="xref" href="build_environment.html#sec:gradle_configuration_properties">Section&nbsp;20.1, “Configuring the build environment via gradle.properties”</a>). Unless you provide specific number of parallel threads Gradle attempts to choose the right number based on available CPU cores. Every parallel worker exclusively owns a given project while executing a task. This means that 2 tasks from the same project are never executed in parallel. Therefore only multi-project builds can take advantage of parallel execution. Task dependencies are fully supported and parallel workers will start executing upstream tasks first. Bear in mind that the alphabetical scheduling of decoupled tasks, known from the sequential execution, does not really work in parallel mode. You need to make sure the task dependencies are declared correctly to avoid ordering issues.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:decoupled_projects"></a>56.9.&nbsp;解耦的项目</h2>
       <h4 class="title"><a name="sec:decoupled_projects"></a>56.9.&nbsp;Decoupled Projects</h4>
      </div>
     </div>
    </div>
    <p>Gradle 允许任何项目在配置和执行阶段期间访问其他项目。虽然这为构建作者提供了很大的控制性和灵活性，但也限制了 Gradle 在构建这些项目时本身所具有的灵活性。例如，项目的紧<span class="emphasis"><em>耦合</em></span>会阻碍 Gradle 以并行方式构建多项目，或阻碍以预构建的工件替代项目依赖。 <br>Gradle allows any project to access any other project during both the configuration and execution phases. While this provides a great deal of power and flexibility to the build author, it also limits the flexibility that Gradle has when building those projects. For instance, this tight <span class="emphasis"><em>coupling</em></span> of projects effectively prevents Gradle from building multiple projects in parallel, or from substituting a pre-built artifact in place of a project dependency.</p>
    <p>如果两个项目不直接访问彼此的项目模型，那么它们就被认为是<span class="emphasis"><em>解耦的</em></span>。解耦的项目可能只在声明依赖方面会互相影响：项目依赖（《<a class="xref" href="dependency_management.html#sub:project_dependencies">第50.4.3节，项目依赖</a>》），或者是任务依赖（《<a class="xref" href="tutorial_using_tasks.html#sec:task_dependencies">第6.5节，任务依赖</a>》）。任何其他形式的项目交互（即通过修改另一个项目对象或从另一个项目对象中读值)都会导致项目耦合。 <br>Two projects are said to be <span class="emphasis"><em>decoupled</em></span> if they do not directly access each other's project model. Decoupled projects may only interact in terms of declared dependencies: project dependencies (<a class="xref" href="dependency_management.html#sub:project_dependencies">Section&nbsp;50.4.3, “Project dependencies”</a>) and/or task dependencies (<a class="xref" href="tutorial_using_tasks.html#sec:task_dependencies">Section&nbsp;6.5, “Task dependencies”</a>). Any other form of project interaction (i.e. by modifying another project object or by reading a value from another project object) causes the projects to be coupled.</p>
    <p> 通过使用配置注入（《<a class="xref" href="multi_project_builds.html#sec:cross_project_configuration">第56.1节，跨项目配置</a>》），是一种很常见的使项目耦合的方式。它可能不明显，但是使用关键的 Gradle 功能如 <code class="literal">allprojects</code> 和 <code class="literal">subproject</code> 关键字，会自动导致你的项目耦合。这是因为这些关键字在定义项目的 <code class="literal">build.gradle</code> 文件中使用。而通常这是一个“根项目”，它只定义公共配置而不执行其他操作，但对 Gradle 而言这个根项目仍然是一个完全成熟的项目，并且通过使用 <code class="literal">allprojects</code>，该项目实际上就和所有其他项目耦合了。 <br>A very common way for projects to be coupled is by using configuration injection (<a class="xref" href="multi_project_builds.html#sec:cross_project_configuration">Section&nbsp;56.1, “Cross project configuration”</a>). It may not be immediately apparent, but using key Gradle features like the <code class="literal">allprojects</code> and <code class="literal">subprojects</code> keywords automatically cause your projects to be coupled. This is because these keywords are used in a <code class="literal">build.gradle</code> file, which defines a project. Often this is a "root project" that does nothing more than define common configuration, but as far as Gradle is concerned this root project is still a fully-fledged project, and by using <code class="literal">allprojects</code> that project is effectively coupled to all other projects.</p>
    <p>这意味着使用任何形式的共享构建脚本逻辑或配置注入(<code class="literal">allproject</code>，<code class="literal">subprojects</code>等）都会导致你的项目耦合。当我们扩展项目解耦的概念，并提供利用去耦项目的功能时，我们也将引入新功能来帮助你解决常见的情况（如配置注入）而不会导致项目耦合。 <br>This means that using any form of shared build script logic or configuration injection (<code class="literal">allprojects</code>, <code class="literal">subprojects</code>, etc.) will cause your projects to be coupled. As we extend the concept of project decoupling and provide features that take advantage of decoupled projects, we will also introduce new features to help you to solve common use cases (like configuration injection) without causing your projects to be coupled.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:multiproject_build_and_test"></a>56.10.&nbsp;多项目构建和测试</h2>
       <h4 class="title"><a name="sec:multiproject_build_and_test"></a>56.10.&nbsp;Multi-Project Building and Testing</h4>
      </div>
     </div>
    </div>
    <p>Java 插件的 <code class="literal">build</code> 任务通常用于一个项目的编译、测试和执行代码风格检查（如果使用了 CodeQuality 插件的话)。在多项目构建中，你可能经常想在一系列项目中执行所有这些任务。<code class="literal">buildNeeded</code> 和 <code class="literal">buildDependents</code> 任务能够帮助完成这一点。 <br>The <code class="literal">build</code> task of the Java plugin is typically used to compile, test, and perform code style checks (if the CodeQuality plugin is used) of a single project. In multi-project builds you may often want to do all of these tasks across a range of projects. The <code class="literal">buildNeeded</code> and <code class="literal">buildDependents</code> tasks can help with this.</p>
    <p>我们使用<a class="xref" href="multi_project_builds.html#javadependencies_2" title="示例 56.25.&nbsp;项目库依赖">示例 56.25，项目库依赖</a>中显示的项目结构。在此示例中，:services:personservice 依赖于 :api 和 :shared。:api 项目还依赖于:shared。 <br>Let's use the project structure shown in <a class="xref" href="multi_project_builds.html#javadependencies_2" title="Example&nbsp;56.25.&nbsp;Project lib dependencies">Example&nbsp;56.25, “Project lib dependencies”</a>. In this example :services:personservice depends on both :api and :shared. The :api project also depends on :shared.</p>
    <p>假设你正在处理 :api 这一个项目，你做了一些修改，但由于执行了 clean 以来还没有构建整个项目。你希望构建所有必需的支持 jar，但只对这个做了修改的项目执行代码质量和单元测试，这正是 <code class="literal">build</code> 任务执行的。 <br>Assume you are working on a single project, the :api project. You have been making changes, but have not built the entire project since performing a clean. You want to build any necessary supporting jars, but only perform code quality and unit tests on the project you have changed. The <code class="literal">build</code> task does this.</p>
    <div class="example">
     <a name="multitestingBuild"></a>
     <p class="title"><b>示例 56.27. 构建和测试单个项目 - Example&nbsp;56.27.&nbsp;Build and Test Single Project</b></p>
     <div class="example-contents">
      <p><strong class="userinput"><code>gradle :api:build</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle :api:build</code></strong></p>
      <pre class="screen">&gt; gradle :api:build
:shared:compileJava
:shared:processResources
:shared:classes
:shared:jar
:api:compileJava
:api:processResources
:api:classes
:api:jar
:api:assemble
:api:compileTestJava
:api:processTestResources
:api:testClasses
:api:test
:api:check
:api:build

BUILD SUCCESSFUL

Total time: 1 secs</pre>
     </div>
    </div>
    <br class="example-break">
    <p>当你在典型的开发周期中反复构建并测试对 :api 项目所作的修改（要知道你只修改了这个项目中的一个文件）时，你可能不想查看 :shared 项目中所修改的内容时承担 :shared:compile 检查的成本。添加 <code class="literal">-a</code> 选项能够让 Gradle 使用缓存的 jar 来解析所有项目库依赖，而不会尝试重新构建所依赖的项目。 <br>While you are working in a typical development cycle repeatedly building and testing changes to the :api project (knowing that you are only changing files in this one project), you may not want to even suffer the expense of :shared:compile checking to see what has changed in the :shared project. Adding the <code class="literal">-a</code> option will cause Gradle to use cached jars to resolve any project lib dependencies and not try to re-build the depended on projects.</p>
    <div class="example">
     <a name="multitestingBuildDashA"></a>
     <p class="title"><b>示例 56.28. 部分构建和测试单个项目 - Example&nbsp;56.28.&nbsp;Partial Build and Test Single Project</b></p>
     <div class="example-contents">
      <p><strong class="userinput"><code>gradle :api:build</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -a :api:build</code></strong></p>
      <pre class="screen">&gt; gradle -a :api:build
:api:compileJava
:api:processResources
:api:classes
:api:jar
:api:assemble
:api:compileTestJava
:api:processTestResources
:api:testClasses
:api:test
:api:check
:api:build

BUILD SUCCESSFUL

Total time: 1 secs</pre>
     </div>
    </div>
    <br class="example-break">
    <p>如果你刚从版本控制系统中获取到最新的代码，其中包含了 :api 所依赖的其他项目的修改，那么你可能不只想构建所依赖的所有项目，还要对其进行测试。<code class="literal">buildNeeded</code> 任务也用于测试 testRuntime 配置中项目库依赖所配置的所有项目。 <br>If you have just gotten the latest version of source from your version control system which included changes in other projects that :api depends on, you might want to not only build all the projects you depend on, but test them as well. The <code class="literal">buildNeeded</code> task also tests all the projects from the project lib dependencies of the testRuntime configuration.</p>
    <div class="example">
     <a name="multitestingBuildNeeded"></a>
     <p class="title"><b>示例 56.29. 构建和测试所依赖的项目 - Example&nbsp;56.29.&nbsp;Build and Test Depended On Projects</b></p>
     <div class="example-contents">
      <p><strong class="userinput"><code>gradle: api:buildNeeded</code> </strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle :api:buildNeeded</code></strong></p>
      <pre class="screen">&gt; gradle :api:buildNeeded
:shared:compileJava
:shared:processResources
:shared:classes
:shared:jar
:api:compileJava
:api:processResources
:api:classes
:api:jar
:api:assemble
:api:compileTestJava
:api:processTestResources
:api:testClasses
:api:test
:api:check
:api:build
:shared:assemble
:shared:compileTestJava
:shared:processTestResources
:shared:testClasses
:shared:test
:shared:check
:shared:build
:shared:buildNeeded
:api:buildNeeded

BUILD SUCCESSFUL

Total time: 1 secs</pre>
     </div>
    </div>
    <br class="example-break">
    <p>你还可能想要重构 :api 项目中被其他项目使用的部分内容。如果你做这一类的修改，那么只测试 :api 项目是不够的，你还需要测试依赖于 :api 项目的所有项目。<code class="literal">buildDependents</code> 任务也用于测试依赖于（在 testRuntime 配置中）指定项目上的所有项目。 <br>You also might want to refactor some part of the :api project that is used in other projects. If you make these types of changes, it is not sufficient to test just the :api project, you also need to test all projects that depend on the :api project. The <code class="literal">buildDependents</code> task also tests all the projects that have a project lib dependency (in the testRuntime configuration) on the specified project.</p>
    <div class="example">
     <a name="multitestingBuildDependents"></a>
     <p class="title"><b>示例 56.29. 构建和测试依赖它的项目 - Example&nbsp;56.30.&nbsp;Build and Test Dependent Projects</b></p>
     <div class="example-contents">
      <p><strong class="userinput"><code>gradle :api:buildDependents</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle :api:buildDependents</code></strong></p>
      <pre class="screen">&gt; gradle :api:buildDependents
:shared:compileJava
:shared:processResources
:shared:classes
:shared:jar
:api:compileJava
:api:processResources
:api:classes
:api:jar
:api:assemble
:api:compileTestJava
:api:processTestResources
:api:testClasses
:api:test
:api:check
:api:build
:services:personService:compileJava
:services:personService:processResources
:services:personService:classes
:services:personService:jar
:services:personService:assemble
:services:personService:compileTestJava
:services:personService:processTestResources
:services:personService:testClasses
:services:personService:test
:services:personService:check
:services:personService:build
:services:personService:buildDependents
:api:buildDependents

BUILD SUCCESSFUL

Total time: 1 secs</pre>
     </div>
    </div>
    <br class="example-break">
    <p>最后，你可能想要构建和测试所有项目中的所有内容。在根项目文件夹中运行的任何任务，都会导致所有子项目中的同名任务也被运行。因此，你可以只运行 <code class="literal">gradle build</code> 来构建和测试所有项目。 <br>Finally, you may want to build and test everything in all projects. Any task you run in the root project folder will cause that same named task to be run on all the children. So you can just run <code class="literal">gradle build</code> to build and test all projects.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:property_and_method_inheritance"></a>56.11. 属性和方法的继承</h2>
       <h4 class="title"><a name="sec:property_and_method_inheritance"></a>56.11.&nbsp;Property and method inheritance</h4>
      </div>
     </div>
    </div>
    <p>项目中声明的属性和方法将继承到所有子项目。这是配置注入的替代方法，但我们认为，继承的模式并不能反映多项目构建的问题空间。在本用户指南的未来版本中，我们可能会写一下与之有关的更多内容。 <br>Properties and methods declared in a project are inherited to all its subprojects. This is an alternative to configuration injection. But we think that the model of inheritance does not reflect the problem space of multi-project builds very well. In a future edition of this user guide we might write more about this.</p>
    <p>方法继承可能值得使用，尽管 Gradle 的<span class="emphasis"><em>配置注入</em></span>还不支持方法（但会在以后的版本中支持的）。 <br>Method inheritance might be interesting to use as Gradle's <span class="emphasis"><em>Configuration Injection</em></span> does not support methods yet (but will in a future release).</p>
    <p>你可能想知道，为什么我们实现了一个我们显然不喜欢的功能。原因之一是其他工具也有这个功能，而我们希望在功能比较中有这一点:)。我们想为我们的用户提供一种选择。 <br>You might be wondering why we have implemented a feature we obviously don't like that much. One reason is that it is offered by other tools and we want to have the check mark in a feature comparison :). And we like to offer our users a choice.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="N164EA"></a>56.12. 总结</h2>
       <h4 class="title"><a name="N164EA"></a>56.12.&nbsp;Summary</h4>
      </div>
     </div>
    </div>
    <p>写这一章相当耗费精力，可能你读起来也有同样的感受。我们对这一章最后要说的是，使用 Gradle 的多项目构建通常<span class="emphasis"><em>不</em></span>难。你需要记住五个元素：<code class="literal">allproject</code>，<code class="literal"> subproject</code>，<code class="literal">evaluationDependsOn</code>，<code class="literal">evaluationDependsOnChildren</code> 和项目库依赖。<sup>[<a href="#ftn.N164FE" name="N164FE" class="footnote">24</a>]</sup> 使用这些元素，并记住 Gradle 有不同的配置和执行阶段，你就已经可以很灵活地运用它。但当你进入一个陡峭的领域时，Gradle 不会成为你的障碍，并且通常会伴随你带你到峰顶。 <br>Writing this chapter was pretty exhausting and reading it might have a similar effect. Our final message for this chapter is that multi-project builds with Gradle are usually <span class="emphasis"><em>not</em></span> difficult. There are five elements you need to remember: <code class="literal">allprojects</code>, <code class="literal"> subprojects</code>, <code class="literal">evaluationDependsOn</code>, <code class="literal">evaluationDependsOnChildren</code> and project lib dependencies. <sup>[<a href="#ftn.N164FE" name="N164FE" class="footnote">24</a>]</sup> With those elements, and keeping in mind that Gradle has a distinct configuration and execution phase, you have already a lot of flexibility. But when you enter steep territory Gradle does not become an obstacle and usually accompanies and carries you to the top of the mountain.</p>
   </div>
   <div class="footnotes">
    <br>
    <hr align="left" width="100">
    <div class="footnote">
     <p><sup>[<a href="#N16354" name="ftn.N16354" class="para">21</a>] </sup>我们的实际用例是使用 <a class="ulink" href="http://lucene.apache.org/solr" target="_top">http://lucene.apache.org/solr</a>，在上面你访问的每个索引都需要一个单独的 war。这就是我们创建 webapps 分发包的原因之一。Resin servlet 容器允许我们让这样的分发点指向一个基本安装的 servlet 容器中。 <br><sup>[<a href="#N16354" name="ftn.N16354" class="para">21</a>] </sup>The real use case we had, was using <a class="ulink" href="http://lucene.apache.org/solr" target="_top">http://lucene.apache.org/solr</a>, where you need a separate war for each index you are accessing. That was one reason why we have created a distribution of webapps. The Resin servlet container allows us, to let such a distribution point to a base installation of the servlet container.</p>
    </div>
    <div class="footnote">
     <p><sup>[<a href="#N163DA" name="ftn.N163DA" class="para">22</a>] </sup><code class="literal">services</code> 也是一个项目，但我们只是把它用作一个容器。它没有构建脚本，并且其他构建脚本也没有向它注入内容。 <br><sup>[<a href="#N163DA" name="ftn.N163DA" class="para">22</a>] </sup> <code class="literal">services</code> is also a project, but we use it just as a container. It has no build script and gets nothing injected by another build script.</p>
    </div>
    <div class="footnote">
     <p><sup>[<a href="#N163F6" name="ftn.N163F6" class="para">23</a>] </sup>我们在这里实现，是因为它使布局更容易。我们通常将项目的具体内容放在各自项目的构建脚本里。 <br><sup>[<a href="#N163F6" name="ftn.N163F6" class="para">23</a>] </sup>We do this here, as it makes the layout a bit easier. We usually put the project specific stuff into the build script of the respective projects.</p>
    </div>
    <div class="footnote">
     <p><sup>[<a href="#N164FE" name="ftn.N164FE" class="para">24</a>] </sup>因此在 <a class="ulink" href="http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two" target="_top">7 plus 2 Rule </a> 的范围内我们做得很好:) <br><sup>[<a href="#N164FE" name="ftn.N164FE" class="para">24</a>] </sup>So we are well in the range of the <a class="ulink" href="http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two" target="_top">7 plus 2 Rule </a> :)</p>
    </div>
   </div>
  </div>
  <div class="navfooter">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="第五十五章. 构建的生命周期">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="custom_tasks.html" title="第五十七章. 编写自定义任务类">下一章</a>
    </div>
   </div>
  </div>
 </body>
</html>